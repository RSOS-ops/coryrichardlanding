<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cory Richard</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: black;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        font-family: 'Roboto', sans-serif;
      }
      canvas {
        width: 100vw;
        height: 100vh;
      }
      h1 {
        font-size: 4em;
        margin-bottom: 20px;
        text-align: center;
      }
      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        max-width: 40%;
        height: auto;
        border: 3px solid black;
      }
      #sections-container {
        display: flex;
        justify-content: space-around;
        width: 66%;
        margin-top: 20px;
      }
      .section {
        padding: 10px;
        font-size: 2em;
      }
      div > ul[data-time] {
        display: none; /* This hides the list used for text animation initially */
      }
    </style>
  </head>
  <body>
    <div>
      <ul data-time="3000">
        <li data-hue="197" data-role="main-name">C</li>
        <li data-hue="0" data-role="main-name">O</li>
        <li data-hue="197" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">Y</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">I</li>
        <li data-hue="0" data-role="main-name">C</li>
        <li data-hue="197" data-role="main-name">H</li>
        <li data-hue="197" data-role="main-name">A</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">D</li>
        <li data-hue="197" data-role="sections">DJ</li>
        <li data-hue="0" data-role="sections">Music</li>
        <li data-hue="197" data-role="sections">Visual</li>
        <li data-hue="45" data-role="sections">Tech</li>
      </ul>
    </div>
    <canvas></canvas>
    <h1>Coming Soon</h1>
    <div id="sections-container" style="display: none;">
      <div class="section">DJ</div>
      <div class="section">Music</div>
      <div class="section">Visual</div>
      <div class="section">Tech</div>
    </div>
    <script>
      // Controls the density/number of new particles generated each frame.
      // Adjust this value to tune performance versus visual effect.
      const newParticlesPerFrame = 50;

      // Configuration constants
      // Speed adjustments (factor of 3 slower) are now baked directly into these values.
      // Original values are commented for reference.
      const PARTICLE_CONFIG = {
        // TICKS_MULTIPLIER: 0.05, // Original
        TICKS_MULTIPLIER: 0.15, // Adjusted: 0.05 * 3
        // FADE_SPEED_DIVISOR: 50, // Original (used as numerator for fade speed)
        FADE_SPEED_DIVISOR: 16.666666666666668, // Adjusted: 50 / 3
        DEFAULT_HUE: 0,
        DEFAULT_SATURATION: 100,
        DEFAULT_LIGHTNESS: 50
      };

      const MASK_CANVAS_CONFIG = {
        WIDTH: 200,
        HEIGHT: 150,
        FONT_STYLE_TEMPLATE: (size) => `bold ${size}px Arial`,
        FILL_STYLE: '#000',
        IMAGE_DATA_ALPHA_THRESHOLD: 0, // For checking if a pixel is part of the text
        PIXEL_DATA_STRIDE: 4 // RGBA
      };

      const MAIN_FONT_CONFIG = {
        BASE_SIZE: 40,
        Y_RATIO: 0.25, // canvasHeight / 4
        SIZE_Y_OFFSET_RATIO: 0.3333, // fSizeMain / 3
        WIDTH_SCALE_FACTOR: 0.9
      };

      const SECTIONS_FONT_CONFIG = {
        DEFAULT_MAIN_FONT_SIZE_FALLBACK: 30,
        BASE_SIZE_RATIO: 0.6, // Relative to main font size
        Y_RATIO: 0.75, // canvasHeight * 0.75
        MIN_FONT_SIZE: 1
      };

      const PARTICLE_PHYSICS = {
        POSITION_ADJUST_DIVISOR: 300,
        // BASE_LIFESPAN_INCREMENT: 0.003, // Original
        BASE_LIFESPAN_INCREMENT: 0.001, // Adjusted: 0.003 / 3
        // RANDOM_LIFESPAN_DIVISOR: 10, // Original
        RANDOM_LIFESPAN_DIVISOR: 30, // Adjusted: 10 * 3
        MAX_SIZE_RANDOM_FACTOR: 4,
        SLOW_SPEED_DIVISOR: 400,
        FAST_SPEED_DIVISOR: 10,
        FAST_CHANCE_THRESHOLD: 0.05, // Chance for particle to get a fast speed boost
        MIN_PARTICLE_SIZE: 1
      };

      const STATIC_DRAW_CONFIG = {
        // TICK_EFFECT_DIVISOR: 10, // Original
        TICK_EFFECT_DIVISOR: 30, // Adjusted: 10 * 3
        PRIMARY_OPACITY_T_FACTOR: 0.5,
        // SECONDARY_EFFECT_STEP: 0.01, // Original
        SECONDARY_EFFECT_STEP: 0.0033333333333333335, // Adjusted: 0.01 / 3
        SECONDARY_PADDING_DIVISOR_WIDTH_RATIO: 200,
        SECONDARY_OPACITY_FACTOR: 0.2,
        ALTERNATE_RENDERING_MODULO: 2,
        T_THRESHOLD_FOR_ARC: 0.5, // pos.t < 0.5 determines circle vs square
        BASE_PARTICLE_SIZE_DIVISOR: 150,
        ARC_PARTICLE_SIZE_DIVISOR: 500
      };

      const ENGINE_CONFIG = {
        CLEAR_COLOR: '#111',
        GLOBAL_COMPOSITE_OPERATION_LIGHTER: 'lighter',
        GLOBAL_COMPOSITE_OPERATION_SOURCE_OVER: 'source-over'
      };


      const color = (hsl, o) => {
        return `hsla(${hsl.h | 0}, ${hsl.s}%, ${hsl.l}%, ${o})`;
      };

      /**
       * TextSparks class manages the animation of text revealing as sparkling particles.
       * It handles fetching text data from HTML, rendering text to offscreen canvases
       * to create pixel masks, and then animating particles based on these masks.
       */
      class TextSparks {
        constructor() {
          // Overall opacity for the current mask, used for fade effects.
          this.opa = 0;
          // General ticker, primarily used for animation effects in drawStatic.
          this.tick = 0;
          this.drawCB = null; // Callback for requestAnimationFrame, bound to this.draw.
          this.mask = null; // Holds the currently active text mask (particle positions).
          this.canvas = window.document.querySelector('canvas');
          this.engine = this.canvas.getContext('2d');
          this.maskTick = 0; // Counter for the duration a mask stays visible.
          // Callback for the current state in the mask display lifecycle (state machine).
          this.nextMaskCb = this.nextMask.bind(this);
          // Stores pre-rendered text masks for quick swapping and animation.
          this.maskCache = [];
          // Holds all active particles currently being animated. Using a Set for efficient add/delete.
          this.particleMap = new Set();

          this.resize();
          this.fetchData();
          this.buildStackCache();
        }

        /**
         * Pre-renders all text masks defined in the HTML.
         * This is done upfront to ensure smooth transitions between different texts,
         * as the mask generation can be performance-intensive.
         */
        buildStackCache() {
          this.maskCache = this.stack.map((stack) => {
            return this.buildTextMask(stack.texts);
          });
        }

        /**
         * Extracts text content, animation timings (duration, fade-in/out),
         * and color information (hue, saturation, lightness) from HTML `<ul>` and `<li>` elements.
         * Each `<ul>` represents a "stack" or a sequence of texts to display.
         */
        fetchData() {
          this.stackId = -1; // Index of the currently active text stack.
          // Processes each <ul> found in the first <div> of the body.
          this.stack = [...document.querySelectorAll('div > ul')].map(ul => {
            return {
              ticks: PARTICLE_CONFIG.TICKS_MULTIPLIER * (ul.hasAttribute('data-time') ? ul.getAttribute('data-time') : 0),
              fadeIn: ul.hasAttribute('data-fade-in') ? (PARTICLE_CONFIG.FADE_SPEED_DIVISOR / Number(ul.getAttribute('data-fade-in'))) : 0,
              fadeOut: ul.hasAttribute('data-fade-out') ? (PARTICLE_CONFIG.FADE_SPEED_DIVISOR / Number(ul.getAttribute('data-fade-out'))) : 0,
              texts: [...ul.querySelectorAll('li')].map(li => {
                return {
                  text: li.innerHTML.trim(),
                  hsl: {
                    h: li.hasAttribute('data-hue') ? Number(li.getAttribute('data-hue')) : PARTICLE_CONFIG.DEFAULT_HUE,
                    s: li.hasAttribute('data-saturation') ? Number(li.getAttribute('data-saturation')) : PARTICLE_CONFIG.DEFAULT_SATURATION,
                    l: li.hasAttribute('data-lightness') ? Number(li.getAttribute('data-lightness')) : PARTICLE_CONFIG.DEFAULT_LIGHTNESS
                  },
                  role: li.getAttribute('data-role') || ''
                };
              })
            };
          });
        }

        resize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          this.canvas.setAttribute('width', this.width);
          this.canvas.setAttribute('height', this.height);
        }

        /**
         * Converts an array of text objects into a "mask" - a collection of points
         * representing the pixels of the rendered text. This mask is then used to
         * position particles.
         * An offscreen canvas is used for rendering the text and extracting pixel data
         * without affecting the visible display. This allows for precise pixel manipulation.
         */
        buildTextMask(texts) {
          const mask = [];
          const canvasWidth = MASK_CANVAS_CONFIG.WIDTH;
          const canvasHeight = MASK_CANVAS_CONFIG.HEIGHT;

          // Filters texts by their 'role' attribute to handle them differently.
          const mainNameTexts = texts.filter(t => t.role === 'main-name');
          const sectionsTexts = texts.filter(t => t.role === 'sections');

          // Create an offscreen canvas for text rendering and pixel extraction.
          const canvas = document.createElement('canvas');
          const engine = canvas.getContext('2d');
          canvas.setAttribute('width', canvasWidth);
          canvas.setAttribute('height', canvasHeight);

          const font = MASK_CANVAS_CONFIG.FONT_STYLE_TEMPLATE;
          engine.fillStyle = MASK_CANVAS_CONFIG.FILL_STYLE;

          if (mainNameTexts.length > 0) {
            const mainNameString = mainNameTexts.map(t => t.text).join('');
            const baseMainFontSize = MAIN_FONT_CONFIG.BASE_SIZE;
            engine.font = font(baseMainFontSize);
            let mMain = engine.measureText(mainNameString);
            let fSizeMain = Math.min(baseMainFontSize, (canvasWidth * MAIN_FONT_CONFIG.WIDTH_SCALE_FACTOR / mMain.width) * baseMainFontSize);
            engine.font = font(fSizeMain);
            mMain = engine.measureText(mainNameString);
            const fontWidthMain = mMain.width;
            const yMainName = (canvasHeight * MAIN_FONT_CONFIG.Y_RATIO) + (fSizeMain * MAIN_FONT_CONFIG.SIZE_Y_OFFSET_RATIO);
            let currentXMainName = (canvasWidth - fontWidthMain) / 2;

            // Part 1: Process texts designated as 'main-name'.
            mainNameTexts.forEach(textStack => {
              engine.clearRect(0, 0, canvasWidth, canvasHeight);
              engine.font = font(fSizeMain);
              engine.fillText(textStack.text, currentXMainName, yMainName);
              const textPartWidth = engine.measureText(textStack.text).width;
              // Get pixel data from the offscreen canvas.
              const data = engine.getImageData(0, 0, canvasWidth, canvasHeight);
              const subStack = [];
              // Iterate through pixel data (RGBA) to find non-transparent pixels.
              // For each visible pixel, its normalized coordinates are stored.
              for (let i = 0; i < data.data.length; i += MASK_CANVAS_CONFIG.PIXEL_DATA_STRIDE) {
                // Check the alpha channel.
                if (data.data[i + 3] > MASK_CANVAS_CONFIG.IMAGE_DATA_ALPHA_THRESHOLD) {
                  const pixelIndex = i / MASK_CANVAS_CONFIG.PIXEL_DATA_STRIDE;
                  const x = (pixelIndex % canvasWidth) / canvasWidth;
                  const y = Math.floor(pixelIndex / canvasWidth) / canvasHeight;
                  subStack.push({
                    x: x,
                    y: y,
                    xy_factor: x * 5 * y * 5, // Pre-calculate xy_factor
                    o: Math.random(),
                    t: Math.random()
                  });
                }
              }
              mask.push({ hsl: textStack.hsl, s: subStack });
              currentXMainName += textPartWidth;
            });
          }

          if (sectionsTexts.length > 0) {
            const sectionsString = sectionsTexts.map(t => t.text).join('');
            // Initialize fSizeMainVal with a default font size.
            // This value will be used if mainNameTexts is empty or its font size cannot be determined.
            let fSizeMainVal = SECTIONS_FONT_CONFIG.DEFAULT_MAIN_FONT_SIZE_FALLBACK; 
            if (mainNameTexts.length > 0) {
              // Ensure engine.font is set (it should be from mainNameTexts processing)
              // and attempt to parse the font size.
              if (engine.font && engine.font.includes("px")) {
                const fontMatch = engine.font.match(/(\d+)px/);
                if (fontMatch && fontMatch[1]) {
                  fSizeMainVal = parseFloat(fontMatch[1]);
                }
                // If fontMatch fails, fSizeMainVal retains its default value.
              }
              // If engine.font was not set or didn't include "px", fSizeMainVal also retains its default.
            }
            // Calculate base font size for sections relative to the main name font size or its default.
            const baseSectionsFontSize = fSizeMainVal * SECTIONS_FONT_CONFIG.BASE_SIZE_RATIO;
            engine.font = font(baseSectionsFontSize);
            let mSections = engine.measureText(sectionsString);
            let fSizeSections = Math.min(baseSectionsFontSize, (canvasWidth * MAIN_FONT_CONFIG.WIDTH_SCALE_FACTOR / mSections.width) * baseSectionsFontSize);
            // Ensure fSizeSections is a positive number, defaulting to 1 if calculation leads to zero or negative.
            fSizeSections = Math.max(fSizeSections, SECTIONS_FONT_CONFIG.MIN_FONT_SIZE); 
            engine.font = font(fSizeSections);
            const fontWidthSections = engine.measureText(sectionsString).width;
            const ySections = (canvasHeight * SECTIONS_FONT_CONFIG.Y_RATIO) + (fSizeSections * MAIN_FONT_CONFIG.SIZE_Y_OFFSET_RATIO); // Using SIZE_Y_OFFSET_RATIO from MAIN_FONT_CONFIG as it's fSize/3
            let currentXSections = (canvasWidth - fontWidthSections) / 2;

            // Part 2: Process texts designated as 'sections'.
            sectionsTexts.forEach(textStack => {
              engine.clearRect(0, 0, canvasWidth, canvasHeight);
              engine.font = font(fSizeSections);
              engine.fillText(textStack.text, currentXSections, ySections);
              const textPartWidth = engine.measureText(textStack.text).width;
              // Get pixel data, similar to 'main-name' processing.
              const data = engine.getImageData(0, 0, canvasWidth, canvasHeight);
              const subStack = [];
              // Iterate through pixel data for 'sections' text.
              for (let i = 0; i < data.data.length; i += MASK_CANVAS_CONFIG.PIXEL_DATA_STRIDE) {
                if (data.data[i + 3] > MASK_CANVAS_CONFIG.IMAGE_DATA_ALPHA_THRESHOLD) {
                  const pixelIndex = i / MASK_CANVAS_CONFIG.PIXEL_DATA_STRIDE;
                  const x = (pixelIndex % canvasWidth) / canvasWidth;
                  const y = Math.floor(pixelIndex / canvasWidth) / canvasHeight;
                  subStack.push({
                    x: x,
                    y: y,
                    xy_factor: x * 5 * y * 5, // Pre-calculate xy_factor
                    o: Math.random(),
                    t: Math.random()
                  });
                }
              }
              mask.push({ hsl: textStack.hsl, s: subStack });
              currentXSections += textPartWidth;
            });
          }
          return mask;
        }

        createNewParticle() {
          for (let i = 0; i < newParticlesPerFrame; i++) {
            let main = Math.random() * this.mask.length | 0;
            let subMask = this.mask[main];
            let maskElement = this.mask[main].s[Math.random() * this.mask[main].s.length | 0];

            if (subMask && maskElement) {
              let particle = {
                x: maskElement.x,
                y: maskElement.y,
                hsl: subMask.hsl,
                c: this.prepareParticle
              };
              this.particleMap.add(particle);
            }
          }
        }

        clear() {
          this.engine.fillStyle = ENGINE_CONFIG.CLEAR_COLOR;
          this.engine.fillRect(0, 0, this.width, this.height);
        }

        randFromList(...rands) {
          return rands.reduce((acc, rand) => {
            return acc + rand;
          }, 0) / rands.length;
        }

        /**
         * Initializes a particle's properties before its first draw.
         * This includes its initial slight positional adjustments, size, lifespan increment (s),
         * and movement vector (mx, my). Random numbers are used extensively here to give
         * each particle a unique behavior and appearance (e.g. speed, direction, initial jitter).
         */
        prepareParticle(particle) {
          const r1 = Math.random(); // Used for various random factors.
          const r2 = Math.random(); // Used for various random factors.
          const r3 = Math.random(); // Used for randomizing radian angle.
          const rad = r3 * Math.PI * 2;

          particle.x += (-0.5 + r1) / PARTICLE_PHYSICS.POSITION_ADJUST_DIVISOR;
          particle.y += (-0.5 + r2) / PARTICLE_PHYSICS.POSITION_ADJUST_DIVISOR;
          particle.si = PARTICLE_PHYSICS.MIN_PARTICLE_SIZE + Math.random() * PARTICLE_PHYSICS.MAX_SIZE_RANDOM_FACTOR | 0;
          particle.s = PARTICLE_PHYSICS.BASE_LIFESPAN_INCREMENT + this.randFromList(r1, r2) / PARTICLE_PHYSICS.RANDOM_LIFESPAN_DIVISOR;
          particle.l = 0;
          const speedDivisor = r1 < PARTICLE_PHYSICS.FAST_CHANCE_THRESHOLD ? PARTICLE_PHYSICS.FAST_SPEED_DIVISOR : PARTICLE_PHYSICS.SLOW_SPEED_DIVISOR;
          particle.mx = Math.cos(rad) * (particle.s / speedDivisor);
          particle.my = Math.sin(rad) * (particle.s / speedDivisor);
          particle.c = this.drawParticle; // Set the particle's draw function.
        }

        /**
         * Updates a particle's state and draws it on the main canvas.
         * Each call progresses the particle's "life" (particle.l).
         * When particle.l >= 1, the particle is considered "dead" and will be removed.
         * Position is updated based on its movement vector (mx, my).
         * Opacity is tied to its life and the overall mask opacity (this.opa),
         * creating a fade-in/out effect for the particle itself.
         */
        drawParticle(particle) {
          // If particle's life is over, mark it for removal.
          if (particle.l >= 1) {
            particle.c = null; // Setting 'c' to null flags it for deletion in renderParticles.
            return;
          }

          particle.l += particle.s; // Increment life.
          particle.x += particle.mx; // Update position.
          particle.y += particle.my;

          // Draw the particle. Opacity uses a sine wave based on life for a pulsing effect.
          this.engine.fillStyle = color(particle.hsl, this.opa * Math.sin(particle.l * Math.PI));
          this.engine.fillRect(particle.x * this.width, particle.y * this.height, particle.si, particle.si);
        }

        renderParticles() {
          this.particleMap.forEach((particle) => {
            particle.c.call(this, particle);
            if (!particle.c) {
              this.particleMap.delete(particle);
            }
          });
        }

        drawStatic() {
          let i = 0;
          const step = STATIC_DRAW_CONFIG.SECONDARY_EFFECT_STEP;
          // Calculate particle sizes once per frame
          const baseParticleSize = this.width / STATIC_DRAW_CONFIG.BASE_PARTICLE_SIZE_DIVISOR;
          const arcParticleBaseSize = this.width / STATIC_DRAW_CONFIG.ARC_PARTICLE_SIZE_DIVISOR;


          this.mask.forEach(subMask => {
            subMask.s.forEach(pos => {
              i++;
              // Use pre-calculated pos.xy_factor
              this.engine.fillStyle = color(subMask.hsl, (1 + Math.cos(pos.xy_factor + this.tick / STATIC_DRAW_CONFIG.TICK_EFFECT_DIVISOR)) / 2 * this.opa * pos.t * STATIC_DRAW_CONFIG.PRIMARY_OPACITY_T_FACTOR);
              this.engine.fillRect(
                pos.x * this.width,
                pos.y * this.height,
                baseParticleSize,
                baseParticleSize
              );

              if (i % STATIC_DRAW_CONFIG.ALTERNATE_RENDERING_MODULO) {
                return;
              }

              pos.o += step;
              const opa = Math.max(0, Math.sin(pos.o * Math.PI * 2));
              const padding = opa * this.width / STATIC_DRAW_CONFIG.SECONDARY_PADDING_DIVISOR_WIDTH_RATIO;

              this.engine.fillStyle = color(subMask.hsl, this.opa * opa * STATIC_DRAW_CONFIG.SECONDARY_OPACITY_FACTOR);

              if (pos.t < STATIC_DRAW_CONFIG.T_THRESHOLD_FOR_ARC) {
                this.engine.beginPath();
                this.engine.arc(
                  pos.x * this.width,
                  pos.y * this.height,
                  arcParticleBaseSize + padding, // Use arcParticleBaseSize
                  0,
                  Math.PI * 2
                );
                this.engine.fill();
              } else {
                this.engine.fillRect(
                  pos.x * this.width - padding,
                  pos.y * this.height - padding,
                  baseParticleSize + padding * 2, // Use baseParticleSize
                  baseParticleSize + padding * 2  // Use baseParticleSize
                );
              }
            });
          });
        }

        /**
         * Main animation loop, called with requestAnimationFrame.
         * Key steps:
         * 1. Advances the mask display state (this.nextMaskCb()).
         * 2. Creates new particles for the current frame (this.createNewParticle()).
         * 3. Clears the canvas (this.clear()).
         * 4. Sets 'lighter' compositing for additive blending of particles.
         * 5. Draws static background elements/effects (this.drawStatic()).
         * 6. Renders all active particles (this.renderParticles()).
         * 7. Resets compositing mode and requests the next frame.
         */
        draw() {
          this.tick++; // Increment global tick.
          this.nextMaskCb(); // Process current state in mask display lifecycle.
          this.createNewParticle(); // Generate new particles.
          this.clear(); // Clear canvas for new frame.

          // 'lighter' makes overlapping colors add up, creating a glowing effect.
          this.engine.globalCompositeOperation = ENGINE_CONFIG.GLOBAL_COMPOSITE_OPERATION_LIGHTER;
          this.drawStatic(); // Draw static elements (background patterns/glows).
          this.renderParticles(); // Draw all active particles.
          // Reset composite operation for other drawing (if any) or for next frame's clear.
          this.engine.globalCompositeOperation = ENGINE_CONFIG.GLOBAL_COMPOSITE_OPERATION_SOURCE_OVER;
          requestAnimationFrame(this.drawCB); // Request next frame.
        }

        // --- Animation State Machine ---
        // The following methods (fadeInMask, afterFadeIn, tickMask, fadeOutMask, afterFadeOut, nextMask)
        // form a simple state machine. `this.nextMaskCb` (nextMaskCallback) is a function pointer
        // that dictates the current state of the text mask's lifecycle.
        // - `nextMask`: Switches to a new text mask from the cache.
        // - `fadeInMask`: Gradually increases opacity of the current mask.
        // - `afterFadeIn`: Called when fade-in is complete; transitions to `tickMask` if timed, or waits.
        // - `tickMask`: Holds the mask visible for a specified duration.
        // - `fadeOutMask`: Gradually decreases opacity of the current mask.
        // - `afterFadeOut`: Called when fade-out is complete; transitions back to `nextMask` for the cycle to repeat.

        fadeInMask() {
          this.opa += this.stack[this.stackId].fadeIn;
          if (this.opa >= 1) {
            this.opa = 1;
            this.afterFadeIn();
          }
        }

        afterFadeIn() {
          this.opa = 1;
          if (this.stack[this.stackId].ticks) {
            this.maskTick = 0;
            this.nextMaskCb = this.tickMask.bind(this);
          } else {
            this.nextMaskCb = () => {};
          }
        }

        fadeOutMask() {
          this.opa -= this.stack[this.stackId].fadeOut;
          if (this.opa <= 0) {
            this.afterFadeOut();
          }
        }

        afterFadeOut() {
          this.opa = 0;
          this.nextMaskCb = this.nextMask.bind(this);
        }

        tickMask() {
          this.maskTick++;
          if (this.maskTick >= this.stack[this.stackId].ticks) {
            if (this.stack[this.stackId].fadeOut) {
              this.nextMaskCb = this.fadeOutMask.bind(this);
            } else {
              this.afterFadeOut();
            }
          }
        }

        nextMask() {
          this.stackId++;
          if (this.stackId >= this.stack.length) {
            this.stackId = 0;
          }
          this.mask = this.maskCache[this.stackId];
          if (this.stack[this.stackId].fadeIn) {
            this.nextMaskCb = this.fadeInMask.bind(this);
          } else {
            this.opa = 1;
            this.afterFadeIn();
          }
        }

        run() {
          this.drawCB = this.draw.bind(this);
          this.drawCB();
        }
      }

      const a = new TextSparks();
      a.run();
    </script>
  </body>
</html>