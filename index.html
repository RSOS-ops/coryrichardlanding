<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cory Richard</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        html {
            margin:0;
            padding:0;
        }
        body {
            background-color: black;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding:0;
            font-family: 'Roboto', sans-serif;
        }
        #staticTextCanvas, #animationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #staticTextCanvas {
            z-index: 0;
        }
        #animationCanvas {
            z-index: 1;
        }
        h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-align: center;
            z-index: 2; /* Ensure h1 is above canvases */
            position: relative; /* Needed for z-index to apply if body isn't positioned */
        }
        div > ul[data-time] {
            display: none;
        }
        #sections-container { /* Keep styles for when it's re-enabled */
            display: flex;
            justify-content: space-around;
            width: 66%;
            margin-top: 20px;
        }
        .section {
            padding: 10px;
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div>
      <ul data-time="3000">
        <li data-hue="197" data-role="main-name">C</li>
        <li data-hue="0" data-role="main-name">O</li>
        <li data-hue="197" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">Y</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">I</li>
        <li data-hue="0" data-role="main-name">C</li>
        <li data-hue="197" data-role="main-name">H</li>
        <li data-hue="197" data-role="main-name">A</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">D</li>
        <li data-hue="197" data-role="sections">DJ</li>
        <li data-hue="0" data-role="sections">Music</li>
        <li data-hue="197" data-role="sections">Visual</li>
        <li data-hue="45" data-role="sections">Tech</li>
      </ul>
    </div>
    <canvas id="staticTextCanvas"></canvas>
    <canvas id="animationCanvas"></canvas>
    <h1>Coming Soon</h1>
    <div id="sections-container" style="display: none;">
        <div class="section">DJ</div>
        <div class="section">Music</div>
        <div class="section">Visual</div>
        <div class="section">Tech</div>
    </div>
    <script>
// Global helper functions
const color = (hsl, o) => {
    return \`hsla(\${hsl.h | 0}, \${hsl.s}%, \${hsl.l}%, \${o})\`;
};
const font = (size) => \`bold \${size}px Arial\`; // Made global for simplicity in this test

class TextSparks
{
    constructor() {
        this.opa    = 0;
        this.tick   = 0;
        this.drawCB = null;
        this.mask   = null;
        this.canvas = window.document.querySelector('#animationCanvas');
        if (this.canvas) {
            this.engine = this.canvas.getContext('2d');
        } else {
            // In a real scenario without console, this error won't be seen by user easily.
            // For now, proceed assuming canvas exists, error will manifest as blank screen.
        }

        this.staticCanvas = window.document.querySelector('#staticTextCanvas');
        if (this.staticCanvas) {
            this.staticEngine = this.staticCanvas.getContext('2d');
        }

        this.maskTick   = 0;
        this.nextMaskCb = null; // this.nextMask.bind(this); // Not needed now
        this.maskCache  = [];

        this.particleMap = new Map();
        this.resize();
        // this.fetchData(); // Disabled
        // this.buildStackCache(); // Disabled
    }

    buildStackCache() { /* Disabled */ }
    fetchData() { /* Disabled */ }
    buildTextMask(texts) { return []; /* Disabled, returns empty mask */ }
    createNewParticle() { /* Disabled */ }
    // clear() { /* Disabled, resize handles initial clear test */ }
    prepareParticle(particle) { /* Disabled */ }
    drawParticle(particle) { /* Disabled */ }
    renderParticles() { /* Disabled */ }
    drawStatic() { /* Disabled */ }
    draw() { /* Disabled */ }
    fadeInMask() { /* Disabled */ }
    afterFadeIn() { /* Disabled */ }
    fadeOutMask() { /* Disabled */ }
    afterFadeOut() { /* Disabled */ }
    tickMask() { /* Disabled */ }
    nextMask() { /* Disabled */ }

    clear() { // This is the original clear method, let's keep it disabled from draw loop for now
        /*
        if(this.engine) {
            this.engine.fillStyle = '#111';
            this.engine.fillRect(0, 0, this.width, this.height);
        }
        */
    }


    randFromList(...rands) {
        return rands.reduce((acc, rand) => acc + rand, 0) / rands.length;
    }

    resize() {
        this.width  = window.innerWidth;
        this.height = window.innerHeight;

        if (this.canvas) {
            this.canvas.setAttribute('width', this.width);
            this.canvas.setAttribute('height', this.height);
            if (this.engine) {
                this.engine.fillStyle = 'darkred'; // Test color for animation canvas
                this.engine.fillRect(0, 0, this.width, this.height);
            }
        }
        if (this.staticCanvas) {
            this.staticCanvas.setAttribute('width', this.width);
            this.staticCanvas.setAttribute('height', this.height);
            if (this.staticEngine) {
                this.staticEngine.fillStyle = 'darkblue'; // Test color for static canvas
                this.staticEngine.fillRect(0, 0, this.width, this.height);
            }
        }
    }

    run() { /* Disabled for this test */ }
}

const a = new TextSparks();
// a.run(); // run() is disabled, constructor calls resize() which does the test drawing.

// To ensure h1 is visible if canvases are full screen
document.addEventListener('DOMContentLoaded', () => {
    const h1 = document.querySelector('h1');
    if (h1) {
        h1.style.zIndex = '2';
        h1.style.position = 'relative'; // Ensure z-index applies
    }
});

    </script>
</body>
</html> 