<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            background-repeat: no-repeat;
        }
        canvas {
            display: block; /* Fixes potential scrollbar issue */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        var canvas = document.getElementById("canvas");

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Initialize the GL context
        var gl = canvas.getContext('webgl');
        if (!gl) {
            console.error("Unable to initialize WebGL.");
            document.body.innerHTML = "Sorry, your browser does not support WebGL, or it is disabled.";
        }

        if (gl) { // Only run WebGL code if context was successfully obtained
            
            var letterTextures = {};
            // Helper function to create a texture from text
            function createTextTexture(gl, text, font, textColor, backgroundColor) {
                // Create a 2D canvas
                const canvas2d = document.createElement('canvas');
                const ctx = canvas2d.getContext('2d');

                // Set font and measure text
                ctx.font = font;
                const textMetrics = ctx.measureText(text);
                
                // Estimate canvas size
                let canvasWidth = Math.pow(2, Math.ceil(Math.log2(textMetrics.width + 20))); // Add some padding
                let actualBoundingBoxAscent = textMetrics.actualBoundingBoxAscent || (parseInt(font, 10) * 0.85); // Fallback for ascent
                let actualBoundingBoxDescent = textMetrics.actualBoundingBoxDescent || (parseInt(font, 10) * 0.35); // Fallback for descent
                let canvasHeight = Math.pow(2, Math.ceil(Math.log2(actualBoundingBoxAscent + actualBoundingBoxDescent + 20))); // Add some padding

                canvas2d.width = canvasWidth;
                canvas2d.height = canvasHeight;

                // Re-set font and properties as canvas size change might reset them
                ctx.font = font; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Fill background
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);

                // Draw text
                ctx.fillStyle = textColor;
                ctx.fillText(text, canvas2d.width / 2, canvas2d.height / 2);

                // Create WebGL texture
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                // Upload the canvas to the texture
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas2d);
                
                // Set texture parameters
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                gl.generateMipmap(gl.TEXTURE_2D); // Generate mipmaps

                gl.bindTexture(gl.TEXTURE_2D, null); // Unbind texture

                return texture;
            }

            //Time
            var time = 0.0;

            //************** Shader sources **************

            var vertexSource = `
attribute vec2 position;
attribute vec2 texCoord; // New: For texture coordinates
varying vec2 vTexCoord;  // New: To pass texCoord to fragment shader
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
    vTexCoord = texCoord; // Pass through texture coordinates
}
`;

            var fragmentSource = `
precision highp float;

uniform float width;
uniform float height;
vec2 resolution = vec2(width, height); // Resolution of the canvas

uniform float time;
uniform sampler2D u_letterTexture; // Texture for the current letter

varying vec2 vTexCoord; // Texture coordinates from vertex shader

// Re-using existing color and effect parameters/functions
vec3 purple = vec3(0.611, 0.129, 0.909);
vec3 green = vec3(0.133, 0.62, 0.698);

// Glow function (can be reused, but 'dist' will now come from texture alpha)
float getGlow(float alphaMask, float radius, float intensity){
  float dist = 1.0 - alphaMask; // Crude distance
  return pow(radius/dist, intensity);
}

void main(){
  vec4 texColor = texture2D(u_letterTexture, vTexCoord);

  if(texColor.a < 0.1) { // Threshold to avoid faint edges if any
    discard;
  }
  
  float t = time * 0.05; // Keep overall time progression

  float mixFactor = fract(t + vTexCoord.x * 0.5); // Vary color across letter and time
  vec3 letterColor = mix(green, purple, mixFactor);

  float glowStrength = getGlow(texColor.a, 0.5, 1.5); // Adjusted radius/intensity
  
  vec3 finalColor = letterColor + glowStrength * letterColor; // Additive glow

  // Tone mapping (optional, can keep)
  finalColor = 1.0 - exp(-finalColor);

  // Gamma correction (optional, can keep)
  finalColor = pow(finalColor, vec3(0.4545));

  gl_FragColor = vec4(finalColor, texColor.a); // Output final color, preserve letter alpha
}
`;

            //************** Utility functions **************

            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.uniform1f(widthHandle, window.innerWidth);
                gl.uniform1f(heightHandle, window.innerHeight);
            }

            //Compile shader and combine with source
            function compileShader(shaderSource, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, shaderSource);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw "Shader compile failed with: " + gl.getShaderInfoLog(shader);
                }
                return shader;
            }

            //From https://codepen.io/jlfwong/pen/GqmroZ
            //Utility to complain loudly if we fail to find the attribute/uniform
            function getAttribLocation(program, name) {
                var attributeLocation = gl.getAttribLocation(program, name);
                if (attributeLocation === -1) {
                    throw 'Cannot find attribute ' + name + '.';
                }
                return attributeLocation;
            }

            function getUniformLocation(program, name) {
                var attributeLocation = gl.getUniformLocation(program, name);
                if (attributeLocation === -1) {
                    throw 'Cannot find uniform ' + name + '.';
                }
                return attributeLocation;
            }

            //************** Create shaders **************

            //Create vertex and fragment shaders
            var vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
            var fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);

            //Create shader programs
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            gl.useProgram(program);

            // ---- BEGIN NEW CODE BLOCK FOR LETTERS ----
            const letters = "CORYRICHARD";
            const letterFontSize = 'bold 128px Roboto'; // Font size for textures
            const letterTextColor = 'white';
            const letterBackgroundColor = 'rgba(0, 0, 0, 0)'; // Transparent background

            // Create textures for each letter
            for (let i = 0; i < letters.length; i++) {
                const char = letters[i];
                if (!letterTextures[char]) { // Avoid re-creating if script is run multiple times in some environments
                    letterTextures[char] = createTextTexture(gl, char, letterFontSize, letterTextColor, letterBackgroundColor);
                }
            }

            // Get handles for new shader variables
            var texCoordHandle = getAttribLocation(program, 'texCoord');
            var letterTextureUniformLocation = getUniformLocation(program, 'u_letterTexture');
            // ---- END NEW CODE BLOCK FOR LETTERS ----
            // var positionHandle = getAttribLocation(program, 'position'); // This should already be defined from before

            // ---- BEGIN VBO AND DRAW LOGIC FOR LETTERS ----

            const letterSpacing = 0.15; // normalized screen space for spacing between letters
            const letterSize = 0.1;   // normalized screen space for letter size (height)
            const totalLetters = letters.length;
            const totalWidth = (totalLetters -1) * letterSpacing;
            let startX = -totalWidth / 2;

            let allVertexData = [];

            for (let i = 0; i < totalLetters; i++) {
                const char = letters[i];
                // For simplicity, assume square textures for now. Adjust aspect ratio if needed.
                // Quad vertices (x, y) - two triangles
                // Triangle 1: top-left, bottom-left, top-right
                // Triangle 2: top-right, bottom-left, bottom-right
                
                // Letter quad centered at (currentX, 0) for now, adjust Y as needed
                let currentX = startX + i * letterSpacing;

                // Positions (centered around currentX, 0 for now, Y can be adjusted)
                // Adjust Y if you want the text baseline somewhere else. For now, centered vertically.
                let x1 = currentX - letterSize / 2;
                let x2 = currentX + letterSize / 2;
                let y1 = -letterSize / 2; // Top of letter quad
                let y2 = letterSize / 2;  // Bottom of letter quad

                // UVs (assuming standard texture coordinates)
                const u1 = 0.0;
                const v1 = 0.0; // Top-left of texture
                const u2 = 1.0;
                const v2 = 1.0; // Bottom-right of texture

                allVertexData.push(
                    // Triangle 1
                    x1, y1, u1, v1, // Top-left
                    x1, y2, u1, v2, // Bottom-left
                    x2, y1, u2, v1, // Top-right
                    // Triangle 2
                    x2, y1, u2, v1, // Top-right
                    x1, y2, u1, v2, // Bottom-left
                    x2, y2, u2, v2  // Bottom-right
                );
            }

            const letterVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, letterVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allVertexData), gl.STATIC_DRAW);

            // Configure vertex attributes
            const STRIDE = 4 * Float32Array.BYTES_PER_ELEMENT; // x, y, u, v (4 floats)

            gl.enableVertexAttribArray(positionHandle);
            gl.vertexAttribPointer(positionHandle, 2, gl.FLOAT, false, STRIDE, 0); // First 2 floats are position

            gl.enableVertexAttribArray(texCoordHandle);
            gl.vertexAttribPointer(texCoordHandle, 2, gl.FLOAT, false, STRIDE, 2 * Float32Array.BYTES_PER_ELEMENT); // Next 2 floats are texCoords

            //Set uniform handle (these should already be defined and initialized)
            var timeHandle = getUniformLocation(program, 'time'); // Ensure timeHandle is defined
            var widthHandle = getUniformLocation(program, 'width'); // Ensure widthHandle is defined
            var heightHandle = getUniformLocation(program, 'height'); // Ensure heightHandle is defined
            gl.uniform1f(widthHandle, window.innerWidth); // Set initial width
            gl.uniform1f(heightHandle, window.innerHeight); // Set initial height


            var lastFrame = Date.now();
            var thisFrame;

            function draw() {
                thisFrame = Date.now();
                time += (thisFrame - lastFrame) / 1000.0; // Ensure float division
                lastFrame = thisFrame;

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.useProgram(program); // Ensure program is used

                // Update global uniforms
                gl.uniform1f(timeHandle, time);
                // width and height uniforms are set once unless window resizes, 
                // onWindowResize handles their update.

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Standard alpha blending

                gl.bindBuffer(gl.ARRAY_BUFFER, letterVBO); // Bind the letter VBO

                // Re-setup attribute pointers (important if VBO or program changes, good practice in draw)
                // If VBO/program doesn't change per frame, these can be set once after VBO creation.
                // For simplicity here, setting them before the loop.
                gl.vertexAttribPointer(positionHandle, 2, gl.FLOAT, false, STRIDE, 0);
                gl.vertexAttribPointer(texCoordHandle, 2, gl.FLOAT, false, STRIDE, 2 * Float32Array.BYTES_PER_ELEMENT);
                gl.enableVertexAttribArray(positionHandle); // Ensure enabled
                gl.enableVertexAttribArray(texCoordHandle);   // Ensure enabled


                for (let i = 0; i < letters.length; i++) {
                    const char = letters[i];
                    const texture = letterTextures[char];

                    if (texture) {
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.uniform1i(letterTextureUniformLocation, 0); // Tell sampler to use texture unit 0

                        // Draw the 6 vertices for the current letter's quad
                        gl.drawArrays(gl.TRIANGLES, i * 6, 6);
                    }
                }

                requestAnimationFrame(draw);
            }

            // ---- END VBO AND DRAW LOGIC FOR LETTERS ----

            draw(); // Call draw to start the loop
        } // end if (gl)
    </script>
</body>
</html>

