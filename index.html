<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cory Richard</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: black;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        font-family: 'Roboto', sans-serif;
      }
      canvas {
        width: 100vw;
        height: 100vh;
      }
      h1 {
        font-size: 4em;
        margin-bottom: 20px;
        text-align: center;
      }
      img {
        display: block;
        margin-left: auto;
        margin-right: auto;
        max-width: 40%;
        height: auto;
        border: 3px solid black;
      }
      #sections-container {
        display: flex;
        justify-content: space-around;
        width: 66%;
        margin-top: 20px;
      }
      .section {
        padding: 10px;
        font-size: 2em;
      }
      div > ul[data-time] {
        display: none; /* This hides the list used for text animation initially */
      }
    </style>
  </head>
  <body>
    <div>
      <ul data-time="3000">
        <li data-hue="197" data-role="main-name">C</li>
        <li data-hue="0" data-role="main-name">O</li>
        <li data-hue="197" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">Y</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">I</li>
        <li data-hue="0" data-role="main-name">C</li>
        <li data-hue="197" data-role="main-name">H</li>
        <li data-hue="197" data-role="main-name">A</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">D</li>
        <li data-hue="197" data-role="sections">DJ</li>
        <li data-hue="0" data-role="sections">Music</li>
        <li data-hue="197" data-role="sections">Visual</li>
        <li data-hue="45" data-role="sections">Tech</li>
      </ul>
    </div>
    <canvas></canvas>
    <h1>Coming Soon</h1>
    <div id="sections-container" style="display: none;">
      <div class="section">DJ</div>
      <div class="section">Music</div>
      <div class="section">Visual</div>
      <div class="section">Tech</div>
    </div>
    <script>
      const newParticlesPerFrame = 15;

      const formatHSLColor = (hslColor, opacity) => {
        return `hsla(${hslColor.h | 0}, ${hslColor.s}%, ${hslColor.l}%, ${opacity})`;
      };

      class TextSparks {
        constructor() {
          this.currentOpacity = 0;
          this.animationTick = 0;
          this.drawCallback = null;
          this.currentMask = null;
          this.canvas = window.document.querySelector('canvas');
          this.renderingEngine = this.canvas.getContext('2d');
          this.maskTick = 0;
          this.nextMaskCallback = this.nextMask.bind(this);
          this.maskCache = [];

          this.resize();
          this.fetchData();
          this.buildStackCache();
          this.particleMap = new Map();
        }

        buildStackCache() {
          this.maskCache = this.textAnimationStack.map((stackItem) => {
            return this.buildTextMask(stackItem.texts);
          });
        }

        fetchData() {
          this.currentStackId = -1;
          this.textAnimationStack = [...document.querySelectorAll('div > ul')].map(ulElement => {
            return {
              durationTicks: 0.05 * (ulElement.hasAttribute('data-time') ? ulElement.getAttribute('data-time') : 0),
              fadeInSpeed: ulElement.hasAttribute('data-fade-in') ? 50 / Number(ulElement.getAttribute('data-fade-in')) : 0,
              fadeOutSpeed: ulElement.hasAttribute('data-fade-out') ? 50 / Number(ulElement.getAttribute('data-fade-out')) : 0,
              texts: [...ulElement.querySelectorAll('li')].map(liElement => {
                return {
                  text: liElement.innerHTML.trim(),
                  hslColor: {
                    h: liElement.hasAttribute('data-hue') ? Number(liElement.getAttribute('data-hue')) : 0,
                    s: liElement.hasAttribute('data-saturation') ? Number(liElement.getAttribute('data-saturation')) : 100,
                    l: liElement.hasAttribute('data-lightness') ? Number(liElement.getAttribute('data-lightness')) : 50
                  },
                  role: liElement.getAttribute('data-role') || ''
                };
              })
            };
          });
        }

        resize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          this.canvas.setAttribute('width', this.width);
          this.canvas.setAttribute('height', this.height);
        }

        buildTextMask(texts) {
          const maskPixelData = [];
          const canvasWidth = 200;
          const canvasHeight = 150;

          const mainNameTexts = texts.filter(t => t.role === 'main-name');
          const sectionsTexts = texts.filter(t => t.role === 'sections');

          const offscreenCanvas = document.createElement('canvas');
          const offscreenContext = offscreenCanvas.getContext('2d');
          offscreenCanvas.setAttribute('width', canvasWidth);
          offscreenCanvas.setAttribute('height', canvasHeight);

          const getFontString = (size) => `bold ${size}px Arial`;
          offscreenContext.fillStyle = '#000';

          if (mainNameTexts.length > 0) {
            const mainNameString = mainNameTexts.map(t => t.text).join('');
            const baseMainFontSize = 40;
            let mainFontString = getFontString(baseMainFontSize);
            offscreenContext.font = mainFontString;
            let mainTextMetrics = offscreenContext.measureText(mainNameString);

            let mainFontSize = baseMainFontSize;
            if (mainTextMetrics.width > canvasWidth * 0.9) {
              mainFontSize = Math.min(baseMainFontSize, (canvasWidth * 0.9 / mainTextMetrics.width) * baseMainFontSize);
            }
            mainFontString = getFontString(mainFontSize);
            offscreenContext.font = mainFontString;
            // Re-measure with the potentially adjusted font size
            mainTextMetrics = offscreenContext.measureText(mainNameString);
            const fontWidthMain = mainTextMetrics.width;

            const yMainName = (canvasHeight / 4) + (mainFontSize / 3);
            let currentXPositionMain = (canvasWidth - fontWidthMain) / 2;

            mainNameTexts.forEach(textStack => {
              offscreenContext.clearRect(0, 0, canvasWidth, canvasHeight);
              // Font string is already set for mainFontSize if it didn't change
              // or set to the new mainFontSize if it did.
              offscreenContext.font = mainFontString; 
              offscreenContext.fillText(textStack.text, currentXPositionMain, yMainName);
              const textPartWidth = offscreenContext.measureText(textStack.text).width;
              const imageData = offscreenContext.getImageData(0, 0, canvasWidth, canvasHeight);
              const pixelCoordinates = [];
              for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) { // Check alpha channel
                  const pixelIndex = i / 4;
                  pixelCoordinates.push({
                    x: (pixelIndex % canvasWidth) / canvasWidth, // Normalized x
                    y: Math.floor(pixelIndex / canvasWidth) / canvasHeight, // Normalized y
                    initialOffset: Math.random(), // For static animation variation
                    randomSeed: Math.random() // For static animation variation
                  });
                }
              }
              maskPixelData.push({ hslColor: textStack.hslColor, pixelCoordinates: pixelCoordinates });
              currentXPositionMain += textPartWidth;
            });
          }

          if (sectionsTexts.length > 0) {
            const sectionsString = sectionsTexts.map(t => t.text).join('');
            let mainFontSizeValue = 30; // Default if mainNameTexts was empty or font not set
            if (mainNameTexts.length > 0 && mainFontString.includes("px")) { // Use mainFontString here
              const fontMatch = mainFontString.match(/(\d+)px/);
              if (fontMatch && fontMatch[1]) {
                mainFontSizeValue = parseFloat(fontMatch[1]);
              }
            }
            const baseSectionsFontSize = mainFontSizeValue * 0.6;
            let sectionsFontString = getFontString(baseSectionsFontSize);
            offscreenContext.font = sectionsFontString;
            let sectionsTextMetrics = offscreenContext.measureText(sectionsString);
            
            let sectionsFontSize = baseSectionsFontSize;
            if (sectionsTextMetrics.width > canvasWidth * 0.9) {
                sectionsFontSize = Math.min(baseSectionsFontSize, (canvasWidth * 0.9 / sectionsTextMetrics.width) * baseSectionsFontSize);
            }
            sectionsFontSize = Math.max(sectionsFontSize, 1); // Ensure font size is at least 1
            sectionsFontString = getFontString(sectionsFontSize);
            offscreenContext.font = sectionsFontString;
            // Re-measure with the potentially adjusted font size
            sectionsTextMetrics = offscreenContext.measureText(sectionsString);
            const fontWidthSections = sectionsTextMetrics.width;

            const ySections = (canvasHeight * 0.75) + (sectionsFontSize / 3);
            let currentXPositionSections = (canvasWidth - fontWidthSections) / 2;

            sectionsTexts.forEach(textStack => {
              offscreenContext.clearRect(0, 0, canvasWidth, canvasHeight);
              offscreenContext.font = sectionsFontString; // Reuse sectionsFontString
              offscreenContext.fillText(textStack.text, currentXPositionSections, ySections);
              const textPartWidth = offscreenContext.measureText(textStack.text).width;
              const imageData = offscreenContext.getImageData(0, 0, canvasWidth, canvasHeight);
              const pixelCoordinates = [];
              for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) { // Check alpha channel
                  const pixelIndex = i / 4;
                  pixelCoordinates.push({
                    x: (pixelIndex % canvasWidth) / canvasWidth, // Normalized x
                    y: Math.floor(pixelIndex / canvasWidth) / canvasHeight, // Normalized y
                    initialOffset: Math.random(), // For static animation variation
                    randomSeed: Math.random() // For static animation variation
                  });
                }
              }
              maskPixelData.push({ hslColor: textStack.hslColor, pixelCoordinates: pixelCoordinates });
              currentXPositionSections += textPartWidth;
            });
          }
          return maskPixelData;
        }

        createNewParticle() {
          for (let i = 0; i < newParticlesPerFrame; i++) {
            let maskGroupIndex = Math.random() * this.currentMask.length | 0;
            let selectedMaskGroup = this.currentMask[maskGroupIndex];
            // Ensure selectedMaskGroup and its pixelCoordinates are valid before proceeding
            if (selectedMaskGroup && selectedMaskGroup.pixelCoordinates && selectedMaskGroup.pixelCoordinates.length > 0) {
              let selectedMaskParticleInfo = selectedMaskGroup.pixelCoordinates[Math.random() * selectedMaskGroup.pixelCoordinates.length | 0];

              if (selectedMaskParticleInfo) {
                let particle = {
                  x: selectedMaskParticleInfo.x,
                  y: selectedMaskParticleInfo.y,
                  hslColor: selectedMaskGroup.hslColor,
                  // Assigns the initial state function for the particle
                  updateFunction: this.prepareParticle
                };
                this.particleMap.set(particle, particle);
              }
            }
          }
        }

        secLog(log, timesPerFrame) {
          if (Math.random() < 1 / 60 / timesPerFrame) {
            console.log(log);
          }
        }

        clear() {
          this.renderingEngine.fillStyle = '#111';
          this.renderingEngine.fillRect(0, 0, this.width, this.height);
        }

        averageRandomValues(...randomValues) {
          return randomValues.reduce((accumulator, currentValue) => {
            return accumulator + currentValue;
          }, 0) / randomValues.length;
        }

        // Prepares a new particle's properties before its first draw.
        // This function acts as the initial state in a state pattern for particles.
        prepareParticle(particle) {
          const randomFactor1 = Math.random();
          const randomFactor2 = Math.random();
          const randomFactor3 = Math.random();
          const randomAngle = randomFactor3 * Math.PI * 2;

          particle.x += (-0.5 + randomFactor1) / 300;
          particle.y += (-0.5 + randomFactor2) / 300;
          particle.particleSize = 1 + Math.random() * 4 | 0;
          particle.lifeIncrement = 0.003 + this.averageRandomValues(randomFactor1, randomFactor2) / 10;
          particle.currentLife = 0; // Lifetime progress, 0 to 1
          particle.velocityX = Math.cos(randomAngle) * (particle.lifeIncrement / (randomFactor1 < 0.05 ? 10 : 400));
          particle.velocityY = Math.sin(randomAngle) * (particle.lifeIncrement / (randomFactor1 < 0.05 ? 10 : 400));
          // Transitions particle to the drawing state
          particle.updateFunction = this.drawParticle;
        }

        // Draws a particle and updates its state for the next frame.
        // This function acts as the subsequent state in a state pattern for particles.
        drawParticle(particle) {
          if (particle.currentLife >= 1) {
            particle.updateFunction = null; // Mark for removal
            return;
          }

          particle.currentLife += particle.lifeIncrement;
          particle.x += particle.velocityX;
          particle.y += particle.velocityY;

          this.renderingEngine.fillStyle = formatHSLColor(particle.hslColor, this.currentOpacity * Math.sin(particle.currentLife * Math.PI));
          this.renderingEngine.fillRect(particle.x * this.width, particle.y * this.height, particle.particleSize, particle.particleSize);
        }

        renderParticles() {
          this.particleMap.forEach((particle) => {
            // Calls the current state function (prepareParticle or drawParticle)
            if (particle.updateFunction) {
              particle.updateFunction.call(this, particle);
            }
            // Remove particle if its updateFunction is set to null (e.g., lifetime ended)
            if (!particle.updateFunction) {
              this.particleMap.delete(particle);
            }
          });
        }

        drawStatic() {
          let counter = 0;
          const step = 0.01;

          const baseParticleSize = this.width / 150;
          const arcRadiusBase = this.width / 500;
          const paddingFactorBase = this.width / 200;


          this.currentMask.forEach(maskGroup => {
            maskGroup.pixelCoordinates.forEach(pixelPos => {
              counter++;
              const screenX = pixelPos.x * this.width;
              const screenY = pixelPos.y * this.height;

              this.renderingEngine.fillStyle = formatHSLColor(maskGroup.hslColor, (1 + Math.cos(pixelPos.x * 5 * pixelPos.y * 5 + this.animationTick / 10)) / 2 * this.currentOpacity * pixelPos.randomSeed * 0.5);
              this.renderingEngine.fillRect(
                screenX,
                screenY,
                baseParticleSize,
                baseParticleSize
              );

              if (counter % 2) { // Skip half for performance/visual effect
                return;
              }

              pixelPos.initialOffset += step; // Animate the static particles
              const currentEffectOpacity = Math.max(0, Math.sin(pixelPos.initialOffset * Math.PI * 2));
              const padding = currentEffectOpacity * paddingFactorBase;

              this.renderingEngine.fillStyle = formatHSLColor(maskGroup.hslColor, this.currentOpacity * currentEffectOpacity * 0.2);

              if (pixelPos.randomSeed < 0.5) { // Alternate visual effect
                this.renderingEngine.beginPath();
                this.renderingEngine.arc(
                  screenX,
                  screenY,
                  arcRadiusBase + padding,
                  0,
                  Math.PI * 2
                );
                this.renderingEngine.fill();
              } else {
                this.renderingEngine.fillRect(
                  screenX - padding,
                  screenY - padding,
                  baseParticleSize + padding * 2,
                  baseParticleSize + padding * 2
                );
              }
            });
          });
        }

        draw() {
          this.animationTick++;
          this.nextMaskCallback();
          this.createNewParticle();
          this.clear();
          this.renderingEngine.globalCompositeOperation = 'lighter';
          this.drawStatic();
          this.renderParticles();
          this.renderingEngine.globalCompositeOperation = 'source-over';
          requestAnimationFrame(this.drawCallback);
        }

        fadeInMask() {
          this.currentOpacity += this.textAnimationStack[this.currentStackId].fadeInSpeed;
          if (this.currentOpacity >= 1) {
            this.currentOpacity = 1;
            this.afterFadeIn();
          }
        }

        afterFadeIn() {
          this.currentOpacity = 1;
          if (this.textAnimationStack[this.currentStackId].durationTicks) {
            this.maskTick = 0;
            this.nextMaskCallback = this.tickMask.bind(this);
          } else {
            this.nextMaskCallback = () => {}; // No duration, stay on this mask
          }
        }

        fadeOutMask() {
          this.currentOpacity -= this.textAnimationStack[this.currentStackId].fadeOutSpeed;
          if (this.currentOpacity <= 0) {
            this.afterFadeOut();
          }
        }

        afterFadeOut() {
          this.currentOpacity = 0;
          this.nextMaskCallback = this.nextMask.bind(this); // Proceed to next mask
        }

        tickMask() {
          this.maskTick++;
          if (this.maskTick >= this.textAnimationStack[this.currentStackId].durationTicks) {
            if (this.textAnimationStack[this.currentStackId].fadeOutSpeed) {
              this.nextMaskCallback = this.fadeOutMask.bind(this);
            } else {
              this.afterFadeOut(); // If no fadeOutSpeed, directly go to afterFadeOut
            }
          }
        }

        nextMask() {
          this.currentStackId++;
          if (this.currentStackId >= this.textAnimationStack.length) {
            this.currentStackId = 0; // Loop back to the first mask
          }
          this.currentMask = this.maskCache[this.currentStackId];
          if (this.textAnimationStack[this.currentStackId].fadeInSpeed) {
            this.nextMaskCallback = this.fadeInMask.bind(this);
          } else {
            // No fadeInSpeed, directly set opacity to 1 and call afterFadeIn
            this.currentOpacity = 1;
            this.afterFadeIn();
          }
        }

        run() {
          this.drawCallback = this.draw.bind(this);
          this.drawCallback();
        }
      }

      const textSparksApp = new TextSparks();
      textSparksApp.run();
    </script>
  </body>
</html>