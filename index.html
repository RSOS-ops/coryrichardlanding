<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cory Richard</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        html {
            margin:0;
            padding:0;
            /* font-size:0; Removed due to conflict with existing em-based font sizes */
        }
        body {
            background-color: black;
            color: white; /* Assuming you want white text for contrast */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0; /* Existing, compatible with CodePen */
            padding:0; /* Added from CodePen */
            /* font-size:0; Removed due to conflict with existing em-based font sizes */
            font-family: 'Roboto', sans-serif; /* Added a default font */
        }
        /* div { display:none; } Removed as it hides essential content including the animation div */
        /* canvas {
            width:100vw;
            height:100vh;
        } */
        #staticTextCanvas, #animationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #staticTextCanvas {
            z-index: 0;
        }
        #animationCanvas {
            z-index: 1;
        }
        h1 {
            font-size: 4em; /* "Very large" text */
            margin-bottom: 20px; /* Space between text and image */
            text-align: center;
        }
        img {
            display: block; /* To allow margin auto to work for centering */
            margin-left: auto;
            margin-right: auto;
            max-width: 40%; /* Ensure image is responsive */
            height: auto; /* Maintain aspect ratio */
    border: 3px solid black; /* Changed border color to black */
        }
        #sections-container {
            display: flex;
            justify-content: space-around;
            width: 66%; /* Optional: makes the container take full width */
            margin-top: 20px; /* Add some space above the sections */
        }
        .section {
            padding: 10px;
            font-size: 2em; /* Make section text larger */
        }
        /* Hide the list used for text animation initially */
        div > ul[data-time] {
            display: none;
        }
    </style>
</head>
<body>
    <div>
      <ul data-time="3000">
        <li data-hue="197" data-role="main-name">C</li>
        <li data-hue="0" data-role="main-name">O</li>
        <li data-hue="197" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">Y</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">I</li>
        <li data-hue="0" data-role="main-name">C</li>
        <li data-hue="197" data-role="main-name">H</li>
        <li data-hue="197" data-role="main-name">A</li>
        <li data-hue="45" data-role="main-name">R</li>
        <li data-hue="197" data-role="main-name">D</li>
        <li data-hue="197" data-role="sections">DJ</li>
        <li data-hue="0" data-role="sections">Music</li>
        <li data-hue="197" data-role="sections">Visual</li>
        <li data-hue="45" data-role="sections">Tech</li>
      </ul>
    </div>
    <canvas id="staticTextCanvas"></canvas>
    <canvas id="animationCanvas"></canvas>
    <h1>Coming Soon</h1>
    <div id="sections-container" style="display: none;">
        <div class="section">DJ</div>
        <div class="section">Music</div>
        <div class="section">Visual</div>
        <div class="section">Tech</div>
    </div>
    <script>
const newParticlesPerFrame = 50; // This is not used if createNewParticle's content is correct

const color = (hsl, o) => {
    return \`hsla(\${hsl.h | 0}, \${hsl.s}%, \${hsl.l}%, \${o})\`;
};

// Helper function for font string, assuming it's defined globally or part of TextSparks if used internally consistently
const font = (size) => \`bold \${size}px Arial\`;

class TextSparks
{
    constructor() {
        console.log("TextSparks constructor: Started.");

        this.opa    = 0;
        this.tick   = 0;
        this.drawCB = null;
        this.mask   = null;
        this.canvas = window.document.querySelector('#animationCanvas'); 
        this.engine = this.canvas.getContext('2d');
        
        this.staticCanvas = window.document.querySelector('#staticTextCanvas');
        if (this.staticCanvas) {
            this.staticEngine = this.staticCanvas.getContext('2d');
        } else {
            console.error("#staticTextCanvas not found!");
        }
        console.log("TextSparks constructor: animationCanvas:", this.canvas, "staticCanvas:", this.staticCanvas);
        console.log("TextSparks constructor: animationEngine:", this.engine, "staticEngine:", this.staticEngine);

        this.maskTick   = 0;
        this.nextMaskCb = this.nextMask.bind(this);
        this.maskCache  = [];

        this.resize();
        this.fetchData();
        this.buildStackCache();

        this.particleMap = new Map();
    }

    buildStackCache() {
        this.maskCache = this.stack.map((stack) => {
            return this.buildTextMask(stack.texts);
        });
    }

    fetchData() {
        this.stackId = -1;
        this.stack   = [...document.querySelectorAll('div > ul')].map(ul => {
            return {
                ticks   : 0.05 * (ul.hasAttribute('data-time') ? ul.getAttribute('data-time') : 0),
                fadeIn  : ul.hasAttribute('data-fade-in') ? 50 / Number(ul.getAttribute('data-fade-in')) : 0,
                fadeOut : ul.hasAttribute('data-fade-out') ? 50 / Number(ul.getAttribute('data-fade-out')) : 0,
                texts : [...ul.querySelectorAll('li')].map(li => {
                    return {
                        text : li.innerHTML.trim(),
                        hsl : {
                            h :li.hasAttribute('data-hue') ? Number(li.getAttribute('data-hue')) : 0,
                            s :li.hasAttribute('data-saturation') ? Number(li.getAttribute('data-saturation')) : 100,
                            l :li.hasAttribute('data-lightness') ? Number(li.getAttribute('data-lightness')) : 50
                        },
                        role : li.getAttribute('data-role') || ''
                    };
                })
            };
        });
    }

    resize() {
        this.width  = window.innerWidth;
        this.height = window.innerHeight;

        if(this.canvas){
            this.canvas.setAttribute('width', this.width);
            this.canvas.setAttribute('height', this.height);
        }
        if (this.staticCanvas) {
            this.staticCanvas.setAttribute('width', this.width);
            this.staticCanvas.setAttribute('height', this.height);
        }
        
        if (this.staticEngine) {
            this.staticEngine.clearRect(0, 0, this.width, this.height);
        }
    }

    buildTextMask(texts) {
        const mask = []; // Will remain empty for this simplified test
        const canvasWidth = 200; 
        const canvasHeight = 150; 

        const mainNameTexts = texts.filter(t => t.role === 'main-name');
        const sectionsTexts = texts.filter(t => t.role === 'sections'); 

        const tempRenderCanvas = document.createElement('canvas'); 
        const tempEngine = tempRenderCanvas.getContext('2d');
        tempRenderCanvas.setAttribute('width', canvasWidth);
        tempRenderCanvas.setAttribute('height', canvasHeight);

        // --- Render "main-name" Text (Simplified for Static Only) ---
        if (mainNameTexts.length > 0) {
            const mainNameString = mainNameTexts.map(t => t.text).join('');
            let fSizeMain = 20; // Fixed font size
            
            tempEngine.font = font(fSizeMain); 
            const fontWidthMain = tempEngine.measureText(mainNameString).width;
            
            const yMainName = (canvasHeight / 4) + (fSizeMain / 3); 
            let currentXMainNameOnTemp = (canvasWidth - fontWidthMain) / 2; 

            mainNameTexts.forEach(textStack => { 
                // tempEngine.clearRect(0, 0, canvasWidth, canvasHeight); // Not strictly needed if only drawing once to static
                // tempEngine.fillText(textStack.text, currentXMainNameOnTemp, yMainName); // Drawing on temp also not strictly needed for this test

                if (this.staticEngine && this.width && this.height) { // Ensure staticEngine and dimensions are valid
                    const staticFSizeMain = fSizeMain * (this.width / canvasWidth);
                    this.staticEngine.font = font(staticFSizeMain);
                    this.staticEngine.fillStyle = color(textStack.hsl, 1);
                    const staticXMain = (currentXMainNameOnTemp / canvasWidth) * this.width;
                    const staticYMain = (yMainName / canvasHeight) * this.height;
                    console.log("Static Main-Name:", textStack.text, "Font:", this.staticEngine.font, "Color:", this.staticEngine.fillStyle, "X:", staticXMain, "Y:", staticYMain);
                    this.staticEngine.fillText(textStack.text, staticXMain, staticYMain);
                }
                currentXMainNameOnTemp += tempEngine.measureText(textStack.text).width;
            });
        }

        // --- Render "sections" Text (Simplified for Static Only) ---
        if (sectionsTexts.length > 0) {
            let fSizeSections = 10; 
            tempEngine.font = font(fSizeSections); 
            const spacerWidthOnTemp = tempEngine.measureText(' ').width * 3; 

            let sectionsContentWidthOnTemp = 0;
            sectionsTexts.forEach((item, index) => {
                sectionsContentWidthOnTemp += tempEngine.measureText(item.text).width;
                if (index < sectionsTexts.length - 1) {
                    sectionsContentWidthOnTemp += spacerWidthOnTemp;
                }
            });

            let currentXSectionsOnTemp = (canvasWidth - sectionsContentWidthOnTemp) / 2;
            const ySections = (canvasHeight * 0.75) + (fSizeSections / 3); 

            sectionsTexts.forEach((item, index) => { 
                // tempEngine.clearRect(0, 0, canvasWidth, canvasHeight); // Not strictly needed
                // tempEngine.fillText(item.text, currentXSectionsOnTemp, ySections); // Not strictly needed

                if (this.staticEngine && this.width && this.height) { // Ensure staticEngine and dimensions are valid
                    const staticFSizeSections = fSizeSections * (this.width / canvasWidth);
                    this.staticEngine.font = font(staticFSizeSections);
                    this.staticEngine.fillStyle = color(item.hsl, 1);
                    const staticXSections = (currentXSectionsOnTemp / canvasWidth) * this.width;
                    const staticYSections = (ySections / canvasHeight) * this.height;
                    console.log("Static Section:", item.text, "Font:", this.staticEngine.font, "Color:", this.staticEngine.fillStyle, "X:", staticXSections, "Y:", staticYSections);
                    this.staticEngine.fillText(item.text, staticXSections, staticYSections);
                }
                
                currentXSectionsOnTemp += tempEngine.measureText(item.text).width;
                if (index < sectionsTexts.length - 1) {
                    currentXSectionsOnTemp += spacerWidthOnTemp;
                }
            });
        }
        return mask; // Will be empty
    }

    // createNewParticle() is problematic - REMOVE THE DUPLICATED MASKING/RENDERING LOGIC FROM IT
    // For this test, ensure it does NOT attempt to re-render text or build masks.
    // It should only use this.mask if it's populated (which it won't be in this test).
    createNewParticle() {
        // Temporarily simplified to do nothing if mask is empty, or use it if available
        if (!this.mask || this.mask.length === 0) return; // Guard against empty mask

        for (let i = 0; i < newParticlesPerFrame; i++) {
            let main        = Math.random() * this.mask.length | 0;
            // Ensure this.mask[main] and this.mask[main].s are valid before proceeding
            if (this.mask[main] && this.mask[main].s && this.mask[main].s.length > 0) {
                let subMask     = this.mask[main];
                let maskElement = subMask.s[Math.random() * subMask.s.length | 0];

                if (maskElement) { // Ensure maskElement is not undefined
                    let particle = {
                        x   : maskElement.x,
                        y   : maskElement.y,
                        hsl : subMask.hsl,
                        c   : this.prepareParticle
                    };
                    this.particleMap.set(particle, particle);
                }
            }
        }
    }


    clear() {
        if(this.engine) { // Guard against null engine
            this.engine.fillStyle = '#111';
            this.engine.fillRect(0, 0, this.width, this.height);
        }
    }

    prepareParticle(particle) {
        const r1 = Math.random();
        const r2 = Math.random();
        const r3 = Math.random();
        const rad = r3 * Math.PI * 2;
        particle.x += (-0.5 + r1) / 300;
        particle.y += (-0.5 + r2) / 300;
        particle.si = 1 + Math.random() * 4 | 0;
        particle.s = 0.003 + this.randFromList(r1, r2) / 10;
        particle.l = 0;
        particle.mx = Math.cos(rad) * (particle.s / (r1 < 0.05 ? 10 : 400));
        particle.my = Math.sin(rad) * (particle.s / (r1 < 0.05 ? 10 : 400));
        particle.c = this.drawParticle;
    }
    
    randFromList(...rands) { // Added this missing helper method
        return rands.reduce((acc, rand) => {
            return acc + rand;
        }, 0) / rands.length;
    }

    drawParticle(particle) {
        if (particle.l >= 1) {
            particle.c = null;
            return;
        }
        particle.l += particle.s;
        particle.x += particle.mx;
        particle.y += particle.my;
        if(this.engine){ // Guard
            this.engine.fillStyle = color(particle.hsl, this.opa * Math.sin(particle.l * Math.PI));
            this.engine.fillRect(particle.x * this.width, particle.y * this.height, particle.si, particle.si);
        }
    }

    renderParticles() {
        this.particleMap.forEach((particle) => {
            particle.c.call(this, particle);
            if (!particle.c) {
                this.particleMap.delete(particle);
            }
        });
    }

    drawStatic() { // This refers to the particle static shimmer, not the new static background text
        if (!this.mask || this.mask.length === 0 || !this.engine) return; // Guard

        let i = 0;
        const step = 0.01;
        this.mask.forEach(subMask => {
            if (subMask && subMask.s) { // Guard subMask and subMask.s
                subMask.s.forEach(pos => {
                    i++;
                    this.engine.fillStyle = color(subMask.hsl, (1 + Math.cos(pos.x * 5 * pos.y * 5 + this.tick / 10)) / 2 * this.opa * pos.t * 0.5);
                    this.engine.fillRect(pos.x * this.width, pos.y * this.height, this.width / 150, this.width / 150);
                    if (i % 2) return;
                    pos.o += step;
                    const opa = Math.max(0, Math.sin(pos.o * Math.PI * 2));
                    const padding = opa * this.width / 200;
                    this.engine.fillStyle = color(subMask.hsl, this.opa * opa * 0.2);
                    if (pos.t < 0.5) {
                        this.engine.beginPath();
                        this.engine.arc(pos.x * this.width, pos.y * this.height, this.width / 500  + padding, 0, Math.PI * 2);
                        this.engine.fill();
                    } else {
                        this.engine.fillRect(pos.x * this.width - padding, pos.y * this.height - padding, this.width / 150  + padding * 2, this.width / 150  + padding * 2);
                    }
                });
            }
        });
    }

    draw() {
        this.tick++;
        if(this.nextMaskCb) this.nextMaskCb(); // Guard
        if(this.mask && this.mask.length > 0) this.createNewParticle(); // Only create if mask is valid
        this.clear(); // Clears animation canvas

        if(this.engine) { // Guard
            this.engine.globalCompositeOperation = 'lighter';
            this.drawStatic(); // Particle shimmer
            this.renderParticles();
            this.engine.globalCompositeOperation = 'source-over';
        }
        if(this.drawCB) requestAnimationFrame(this.drawCB); // Guard
    }

    // ... (fadeInMask, afterFadeIn, fadeOutMask, afterFadeOut, tickMask, nextMask are fine) ...
    fadeInMask() {
        if (!this.stack || !this.stack[this.stackId]) return; // Guard
        this.opa += this.stack[this.stackId].fadeIn;
        if (this.opa >= 1) {
            this.opa = 1;
            this.afterFadeIn();
        }
    }

    afterFadeIn() {
        if (!this.stack || !this.stack[this.stackId]) return; // Guard
        this.opa = 1;
        if (this.stack[this.stackId].ticks) {
            this.maskTick   = 0;
            this.nextMaskCb = this.tickMask.bind(this);
        } else {
            this.nextMaskCb = () => {};
        }
    }

    fadeOutMask() {
        if (!this.stack || !this.stack[this.stackId]) return; // Guard
        this.opa -= this.stack[this.stackId].fadeOut;
        if (this.opa <= 0) {
            this.afterFadeOut();
        }
    }

    afterFadeOut() {
        this.opa = 0;
        this.nextMaskCb = this.nextMask.bind(this);
    }

    tickMask() {
        if (!this.stack || !this.stack[this.stackId]) return; // Guard
        this.maskTick++;
        if (this.maskTick >= this.stack[this.stackId].ticks) {
            if (this.stack[this.stackId].fadeOut) {
                this.nextMaskCb = this.fadeOutMask.bind(this);
            } else {
                this.afterFadeOut();
            }
        }
    }

    nextMask() {
        if (!this.stack || this.stack.length === 0) return; // Guard
        this.stackId++;
        if (this.stackId >= this.stack.length) {
            this.stackId = 0;
        }
        if (!this.maskCache) return; // Guard
        this.mask = this.maskCache[this.stackId]; // this.mask could be empty if buildTextMask returns []
        if (this.stack[this.stackId] && this.stack[this.stackId].fadeIn) { // Guard stack item
            this.nextMaskCb = this.fadeInMask.bind(this);
        } else {
            this.opa = 1;
            this.afterFadeIn();
        }
    }


    run() {
        console.log("TextSparks run: Called.");
        this.drawCB = this.draw.bind(this);
        this.drawCB();
    }
}

const a = new TextSparks();
a.run();
    </script>
</body>
</html>